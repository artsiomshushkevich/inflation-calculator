# Cursor Rules

## React Usage

- Use functional components with hooks (useState, useEffect, etc.) exclusively. Avoid class components.
- Every React component must live in its own folder with a single file named after the component. Use `index.js` only for components that have multiple inner sub-components (e.g., Table with TableHeader, TableBody, TableFooter, etc.). Simple components without inner components should not have `index.js` files - import them directly from the component file. Avoid colocating multiple components in one file.
- Use `forwardRef` for components that need ref forwarding (e.g., form inputs, buttons that need DOM access).
- Use the `cn` utility function (from `utils/css.js`) for className merging and conditional classes.
- Prefer composition over configuration when designing component APIs.
- Use proper prop destructuring and spread props (`{...props}`) to pass through additional props.
- Set `displayName` for components that use `forwardRef` for better debugging experience.
- Keep components focused and single-responsibility. Split complex components into smaller, reusable pieces.
- Use React 19 features appropriately and follow React best practices.
- Keep shared UI grouped under `src/components/ui/<component-name>/`. When adding new UI primitives, follow the existing folder layout. Only use `index.js` for components with multiple inner sub-components (like Table). Simple components should be imported directly from their component file (e.g., `Button.jsx`).

## JavaScript Usage

- Use ES modules (import/export) exclusively. Avoid CommonJS require/module.exports.
- Always use arrow functions for component definitions, callbacks, utility functions, etc. Avoid function declarations.
- Use modern JavaScript features (ES2020+): optional chaining (`?.`), nullish coalescing (`??`), template literals, etc.
- Use destructuring for props, objects, and arrays to improve readability.
- Use template literals for string interpolation instead of string concatenation.
- Follow ESLint rules: no unused vars except constants starting with uppercase letters.
- Use meaningful variable names that clearly describe their purpose.
- Prefer `const` over `let`, avoid `var` entirely.
- Use optional chaining (`?.`) and nullish coalescing (`??`) where appropriate for safer code.
- Export statements should be used right with declarations of functionality:
  - ✅ `export const myFunction = () => { /* ... */ }`
  - ❌ `const myFunction = () => { /* ... */ }; export { myFunction }`
- Avoid default exports unless absolutely necessary (e.g., for React component entry points like App.jsx). Prefer named exports for better tree-shaking and explicit imports:
  - ✅ `export const myFunction = () => { /* ... */ }`
  - ❌ `export default myFunction` (unless necessary for component entry points)

## Code Style Standards

- **Curly Brackets for Control Statements**: Always use curly brackets for all control statements (if, else, for, while, try, etc.), even if the block contains only a single statement:
  - ❌ `if (!deferredPrompt) return;`
  - ✅ `if (!deferredPrompt) { return; }`
- **Comments**: Only add comments when there's tricky or non-obvious logic. Avoid comments that merely restate what the code does. Code should be self-descriptive:
  - ❌ `// Increment the counter by one` followed by `counter++;`
  - ✅ `// Adjusting for zero-based index` when the logic is non-obvious
- **Spacing**: Always add empty lines between code blocks to improve readability. Separate logical sections with blank lines:
  - ✅ Separate function definitions, component definitions, and logical code blocks with blank lines
- **NPM Packages**: Use only production-ready, stable NPM packages. Never use alpha, beta, insiders, or other pre-release versions in production code:
  - ❌ `"@tailwindcss/nesting": "^0.0.0-insiders.565cd3e"`
  - ✅ Use stable versions only

## Styling

- Use Tailwind CSS utility classes exclusively. Avoid inline styles or separate CSS files for component styling.
- Use the `cn` utility function for conditional and merged classNames. This ensures proper class merging and conditional application.
- Follow the existing color system using CSS variables in HSL format (defined in `tailwind.config.cjs`).
- Use semantic color names from the theme (primary, secondary, destructive, muted, accent, etc.) instead of hardcoded colors.
- Support dark mode via the `class` strategy. Ensure components work in both light and dark themes.
- Preserve existing visual look-and-feel when making style changes by reusing the same Tailwind utility classes unless there is a strong reason to change them.
- Use responsive utilities (sm:, md:, lg:, xl:, 2xl:) for responsive design patterns.
- Follow the existing spacing and sizing scale defined in Tailwind's default configuration.
- Use the existing border radius scale (lg, md, sm) which are calculated from CSS variables.

## Folder Structure and File Naming

### Folder Structure

```
/src
  /components
    /ui              # Shared UI components like button, input, table
      /button
      /input
      /otherComponent
    /[feature]      # Feature-specific components
  
  /utils            # Shared utility functions including working with CSS classes, internationalization, theming (must have index.js)
  /constants         # Application constants (must have index.js)
  /hooks             # Custom React hooks
  /...               # Other files in root (App.jsx, main.jsx, etc.)
```

### File Naming

- React components: Use PascalCase for file names (e.g., `Button.jsx`, `TableHeader.jsx`, `InstallPrompt.jsx`).
- All other functionality (utilities, hooks, constants, etc.): Use camelCase for file names (e.g., `utils.js`, `i18n.js`, `themeProvider.jsx`).
- Component folders should match the component name in PascalCase.
